module Krikri::Harvesters
  ##
  # A partial interface for MARC XML harvesters. Can be subclassed to create 
  # harvesters handling MARC XML docmuments from various sources.
  #
  # Implement `#get_record(identifier)` and `each_collection(&block)` to 
  # complete the interface.
  class MarcXMLHarvester
    include Krikri::Harvester

    # @!attribute [r] opts
    #   the options to be used in harvesting
    attr_reader :opts

    ##
    # @param opts [Hash]
    # @option opts [Interger, Symbol] :max_records (:unlimited) a maximum 
    #   number of records to harvest
    #
    # @see Krikri::Harvester#initialize
    def initialize(opts = {})
      @max_records = opts.fetch(:max_records, :unlimited)
      super
    end

    ##
    # @return [Hash] A hash documenting the allowable options to pass to
    #   initializers.
    #
    # @see Krikri::Harvester::expected_opts
    def self.expected_opts
      {
        key: :marcxml,
        opts: {
          max_records: {type: :int, required: false},
        }
      }
    end

    ##
    # @see Krikri::Harvester#count
    def count
      raise NotImplementedError
    end

    ##
    # @return [Enumerator::Lazy] an enumerator of the records targeted by this
    #   harvester.
    def records
      enumerate_records.lazy.map { |rec| build_record(rec) }
    end

    ##
    # Gets a single record with the given identifier from the API
    #
    # @return [Enumerator::Lazy] an enumerator over the ids for the records
    #   targeted by this harvester.
    def record_ids
      enumerate_records.lazy.map { |rec| rec.identifier }
    end

    ##
    # @return [String] the content type for the records generated by this
    #   harvester
    def content_type
      'text/xml'
    end

    private

    ##
    # @abstract
    # @yield [Enumerable<IO>] gives a collection of IO objects representing 
    #   XML to be parsed into the record.
    def each_collection(&block)
      raise NotImplementedError
    end

    def enumerate_records
      record_count = 0

      Enumerator.new do |yielder|
        each_collection do |marcxml_io|
          Nokogiri::XML::Reader(marcxml_io).each do |node|
            break if record_count == @max_records

            if node.name == 'record' && 
               node.node_type == Nokogiri::XML::Reader::TYPE_ELEMENT
              yielder << MarcXMLDoc.new(node)
              record_count += 1
            end
          end
        end
      end
    end

    def build_record(marcxml_doc)
      @record_class.build(mint_id(marcxml_doc.identifier),
                          marcxml_doc.source,
                          content_type)
    end
  end

  ##
  # A wrapper around a MARC XML document giving access to the controlfield 001.
  class MarcXMLDoc
    # @!attribute [r] identifier
    # @!attribute [r] source
    attr_reader :identifier, :source

    ##
    # @param nokogiri_doc 
    def initialize(nokogiri_doc)
      @source = nokogiri_doc.outer_xml
      doc = Nokogiri::XML(@source)
      doc.remove_namespaces!

      @identifier = doc.xpath("//controlfield[@tag='001']").text
    end
  end
end
